{"ast":null,"code":"import { __assign, __spreadArray, __read } from 'tslib';\nimport sync, { cancelSync } from 'framesync';\nimport { motionValue } from '../value/index.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { variantPriorityOrder } from './utils/animation-state.mjs';\nimport { createLifecycles } from './utils/lifecycles.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.mjs';\n\nvar visualElement = function visualElement(_a) {\n  var _b = _a.treeType,\n      treeType = _b === void 0 ? \"\" : _b,\n      build = _a.build,\n      _getBaseTarget = _a.getBaseTarget,\n      _makeTargetAnimatable = _a.makeTargetAnimatable,\n      _measureViewportBox = _a.measureViewportBox,\n      renderInstance = _a.render,\n      readValueFromInstance = _a.readValueFromInstance,\n      removeValueFromRenderState = _a.removeValueFromRenderState,\n      _sortNodePosition = _a.sortNodePosition,\n      scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n        props = _a.props,\n        presenceId = _a.presenceId,\n        blockInitialAnimation = _a.blockInitialAnimation,\n        visualState = _a.visualState,\n        shouldReduceMotion = _a.shouldReduceMotion;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var isMounted = false;\n    var latestValues = visualState.latestValues,\n        renderState = visualState.renderState;\n    /**\r\n     * The instance of the render-specific node that will be hydrated by the\r\n     * exposed React ref. So for example, this visual element can host a\r\n     * HTMLElement, plain object, or Three.js object. The functions provided\r\n     * in VisualElementConfig allow us to interface with this instance.\r\n     */\n\n    var instance;\n    /**\r\n     * Manages the subscriptions for a visual element's lifecycle, for instance\r\n     * onRender\r\n     */\n\n    var lifecycles = createLifecycles();\n    /**\r\n     * A map of all motion values attached to this visual element. Motion\r\n     * values are source of truth for any given animated value. A motion\r\n     * value might be provided externally by the component via props.\r\n     */\n\n    var values = new Map();\n    /**\r\n     * A map of every subscription that binds the provided or generated\r\n     * motion values onChange listeners to this visual element.\r\n     */\n\n    var valueSubscriptions = new Map();\n    /**\r\n     * A reference to the previously-provided motion values as returned\r\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n     * if any motion values need to be removed after props are updated.\r\n     */\n\n    var prevMotionValues = {};\n    /**\r\n     * When values are removed from all animation props we need to search\r\n     * for a fallback value to animate to. These values are tracked in baseTarget.\r\n     */\n\n    var baseTarget = __assign({}, latestValues); // Internal methods ========================\n\n    /**\r\n     * On mount, this will be hydrated with a callback to disconnect\r\n     * this visual element from its parent on unmount.\r\n     */\n\n\n    var removeFromVariantTree;\n    /**\r\n     * Render the element with the latest styles outside of the React\r\n     * render lifecycle\r\n     */\n\n    function render() {\n      if (!instance || !isMounted) return;\n      triggerBuild();\n      renderInstance(instance, renderState, props.style, element.projection);\n    }\n\n    function triggerBuild() {\n      build(element, renderState, latestValues, options, props);\n    }\n\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n    /**\r\n     *\r\n     */\n\n\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync.update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\r\n     * Any motion values that are provided to the element when created\r\n     * aren't yet bound to the element, as this would technically be impure.\r\n     * However, we iterate through the motion values and set them to the\r\n     * initial values for this component.\r\n     *\r\n     * TODO: This is impure and we should look at changing this to run on mount.\r\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\r\n     * more a reflection of the test.\r\n     */\n\n\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\r\n     * Determine what role this visual element should take in the variant tree.\r\n     */\n\n\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n\n    var element = __assign(__assign({\n      treeType: treeType,\n\n      /**\r\n       * This is a mirror of the internal instance prop, which keeps\r\n       * VisualElement type-compatible with React's RefObject.\r\n       */\n      current: null,\n\n      /**\r\n       * The depth of this visual element within the visual element tree.\r\n       */\n      depth: parent ? parent.depth + 1 : 0,\n      parent: parent,\n      children: new Set(),\n\n      /**\r\n       *\r\n       */\n      presenceId: presenceId,\n      shouldReduceMotion: shouldReduceMotion,\n\n      /**\r\n       * If this component is part of the variant tree, it should track\r\n       * any children that are also part of the tree. This is essentially\r\n       * a shadow tree to simplify logic around how to stagger over children.\r\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n\n      /**\r\n       * Whether this instance is visible. This can be changed imperatively\r\n       * by the projection tree, is analogous to CSS's visibility in that\r\n       * hidden elements should take up layout, and needs enacting by the configured\r\n       * render function.\r\n       */\n      isVisible: undefined,\n\n      /**\r\n       * Normally, if a component is controlled by a parent's variants, it can\r\n       * rely on that ancestor to trigger animations further down the tree.\r\n       * However, if a component is created after its parent is mounted, the parent\r\n       * won't trigger that mount animation so the child needs to.\r\n       *\r\n       * TODO: This might be better replaced with a method isParentMounted\r\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n\n      /**\r\n       * This can be set by AnimatePresence to force components that mount\r\n       * at the same time as it to mount as if they have initial={false} set.\r\n       */\n      blockInitialAnimation: blockInitialAnimation,\n\n      /**\r\n       * Determine whether this component has mounted yet. This is mostly used\r\n       * by variant children to determine whether they need to trigger their\r\n       * own animations on mount.\r\n       */\n      isMounted: function isMounted() {\n        return Boolean(instance);\n      },\n      mount: function mount(newInstance) {\n        isMounted = true;\n        instance = element.current = newInstance;\n\n        if (element.projection) {\n          element.projection.mount(newInstance);\n        }\n\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n\n        values.forEach(function (value, key) {\n          return bindToMotionValue(key, value);\n        });\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n        element.setProps(props);\n      },\n\n      /**\r\n       *\r\n       */\n      unmount: function unmount() {\n        var _a;\n\n        (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n        cancelSync.update(update);\n        cancelSync.render(render);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        lifecycles.clearAllListeners();\n        instance = undefined;\n        isMounted = false;\n      },\n\n      /**\r\n       * Add a child visual element to our set of children.\r\n       */\n      addVariantChild: function addVariantChild(child) {\n        var _a;\n\n        var closestVariantNode = element.getClosestVariantNode();\n\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function sortNodePosition(other) {\n        /**\r\n         * If these nodes aren't even of the same type we can't compare their depth.\r\n         */\n        if (!_sortNodePosition || treeType !== other.treeType) return 0;\n        return _sortNodePosition(element.getInstance(), other.getInstance());\n      },\n\n      /**\r\n       * Returns the closest variant node in the tree starting from\r\n       * this visual element.\r\n       */\n      getClosestVariantNode: function getClosestVariantNode() {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n\n      /**\r\n       * Expose the latest layoutId prop.\r\n       */\n      getLayoutId: function getLayoutId() {\n        return props.layoutId;\n      },\n\n      /**\r\n       * Returns the current instance.\r\n       */\n      getInstance: function getInstance() {\n        return instance;\n      },\n\n      /**\r\n       * Get/set the latest static values.\r\n       */\n      getStaticValue: function getStaticValue(key) {\n        return latestValues[key];\n      },\n      setStaticValue: function setStaticValue(key, value) {\n        return latestValues[key] = value;\n      },\n\n      /**\r\n       * Returns the latest motion value state. Currently only used to take\r\n       * a snapshot of the visual element - perhaps this can return the whole\r\n       * visual state\r\n       */\n      getLatestValues: function getLatestValues() {\n        return latestValues;\n      },\n\n      /**\r\n       * Set the visiblity of the visual element. If it's changed, schedule\r\n       * a render to reflect these changes.\r\n       */\n      setVisibility: function setVisibility(visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n\n      /**\r\n       * Make a target animatable by Popmotion. For instance, if we're\r\n       * trying to animate width from 100px to 100vw we need to measure 100vw\r\n       * in pixels to determine what we really need to animate to. This is also\r\n       * pluggable to support Framer's custom value types like Color,\r\n       * and CSS variables.\r\n       */\n      makeTargetAnimatable: function makeTargetAnimatable(target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n\n        return _makeTargetAnimatable(element, target, props, canMutate);\n      },\n\n      /**\r\n       * Measure the current viewport box with or without transforms.\r\n       * Only measures axis-aligned boxes, rotate and skew must be manually\r\n       * removed with a re-render to work.\r\n       */\n      measureViewportBox: function measureViewportBox() {\n        return _measureViewportBox(instance, props);\n      },\n      // Motion values ========================\n\n      /**\r\n       * Add a motion value and bind it to this visual element.\r\n       */\n      addValue: function addValue(key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n\n      /**\r\n       * Remove a motion value and unbind any active subscriptions.\r\n       */\n      removeValue: function removeValue(key) {\n        var _a;\n\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n\n      /**\r\n       * Check whether we have a motion value for this key\r\n       */\n      hasValue: function hasValue(key) {\n        return values.has(key);\n      },\n\n      /**\r\n       * Get a motion value for this key. If called with a default\r\n       * value, we'll create one if none exists.\r\n       */\n      getValue: function getValue(key, defaultValue) {\n        var value = values.get(key);\n\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n\n        return value;\n      },\n\n      /**\r\n       * Iterate over our motion values.\r\n       */\n      forEachValue: function forEachValue(callback) {\n        return values.forEach(callback);\n      },\n\n      /**\r\n       * If we're trying to animate to a previously unencountered value,\r\n       * we need to check for it in our state and as a last resort read it\r\n       * directly from the instance (which might have performance implications).\r\n       */\n      readValue: function readValue(key) {\n        var _a;\n\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n\n      /**\r\n       * Set the base target to later animate back to. This is currently\r\n       * only hydrated on creation and when we first read a value.\r\n       */\n      setBaseTarget: function setBaseTarget(key, value) {\n        baseTarget[key] = value;\n      },\n\n      /**\r\n       * Find the base target for a value thats been removed from all animation\r\n       * props.\r\n       */\n      getBaseTarget: function getBaseTarget(key) {\n        if (_getBaseTarget) {\n          var target = _getBaseTarget(props, key);\n\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\r\n       * Build the renderer state based on the latest visual state.\r\n       */\n      build: function build() {\n        triggerBuild();\n        return renderState;\n      },\n\n      /**\r\n       * Schedule a render on the next animation frame.\r\n       */\n      scheduleRender: function scheduleRender() {\n        sync.render(render, false, true);\n      },\n\n      /**\r\n       * Synchronously fire render. It's prefered that we batch renders but\r\n       * in many circumstances, like layout measurement, we need to run this\r\n       * synchronously. However in those instances other measures should be taken\r\n       * to batch reads/writes.\r\n       */\n      syncRender: render,\n\n      /**\r\n       * Update the provided props. Ensure any newly-added motion values are\r\n       * added to our map, old ones removed, and listeners updated.\r\n       */\n      setProps: function setProps(newProps) {\n        if (newProps.transformTemplate || props.transformTemplate) {\n          element.scheduleRender();\n        }\n\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function getProps() {\n        return props;\n      },\n      // Variants ==============================\n\n      /**\r\n       * Returns the variant definition with a given name.\r\n       */\n      getVariant: function getVariant(name) {\n        var _a;\n\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n\n      /**\r\n       * Returns the defined default transition on this component.\r\n       */\n      getDefaultTransition: function getDefaultTransition() {\n        return props.transition;\n      },\n      getTransformPagePoint: function getTransformPagePoint() {\n        return props.transformPagePoint;\n      },\n\n      /**\r\n       * Used by child variant nodes to get the closest ancestor variant props.\r\n       */\n      getVariantContext: function getVariantContext(startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n\n          return context_1;\n        }\n\n        var context = {};\n\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n\n        return context;\n      }\n    });\n\n    return element;\n  };\n};\n\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder), false);\n\nvar numVariantProps = variantProps.length;\nexport { visualElement };","map":{"version":3,"sources":["C:/Users/jeswa/Documents/online-clipboard/frontend/node_modules/framer-motion/dist/es/render/index.mjs"],"names":["__assign","__spreadArray","__read","sync","cancelSync","motionValue","isMotionValue","variantPriorityOrder","createLifecycles","updateMotionValuesFromProps","checkIfControllingVariants","checkIfVariantNode","isVariantLabel","visualElement","_a","_b","treeType","build","getBaseTarget","makeTargetAnimatable","measureViewportBox","renderInstance","render","readValueFromInstance","removeValueFromRenderState","sortNodePosition","scrapeMotionValuesFromProps","options","parent","props","presenceId","blockInitialAnimation","visualState","shouldReduceMotion","isMounted","latestValues","renderState","instance","lifecycles","values","Map","valueSubscriptions","prevMotionValues","baseTarget","removeFromVariantTree","triggerBuild","style","element","projection","update","notifyUpdate","bindToMotionValue","key","value","removeOnChange","onChange","latestValue","onUpdate","removeOnRenderRequest","onRenderRequest","scheduleRender","set","initialMotionValues","undefined","isControllingVariants","isVariantNode","current","depth","children","Set","variantChildren","isVisible","manuallyAnimateOnMount","Boolean","mount","newInstance","addVariantChild","forEach","add","setProps","unmount","remove","delete","clearAllListeners","child","closestVariantNode","getClosestVariantNode","other","getInstance","getLayoutId","layoutId","getStaticValue","setStaticValue","getLatestValues","setVisibility","visibility","target","canMutate","addValue","hasValue","removeValue","get","has","getValue","defaultValue","forEachValue","callback","readValue","setBaseTarget","syncRender","newProps","transformTemplate","updatePropListeners","getProps","getVariant","name","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getVariantContext","startAtParent","context_1","initial","context","i","numVariantProps","name_1","variantProps","prop","length"],"mappings":"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","sourcesContent":["import { __assign, __spreadArray, __read } from 'tslib';\r\nimport sync, { cancelSync } from 'framesync';\r\nimport { motionValue } from '../value/index.mjs';\r\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\r\nimport { variantPriorityOrder } from './utils/animation-state.mjs';\r\nimport { createLifecycles } from './utils/lifecycles.mjs';\r\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\r\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.mjs';\r\n\r\nvar visualElement = function (_a) {\r\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\r\n    return function (_a, options) {\r\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState, shouldReduceMotion = _a.shouldReduceMotion;\r\n        if (options === void 0) { options = {}; }\r\n        var isMounted = false;\r\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\r\n        /**\r\n         * The instance of the render-specific node that will be hydrated by the\r\n         * exposed React ref. So for example, this visual element can host a\r\n         * HTMLElement, plain object, or Three.js object. The functions provided\r\n         * in VisualElementConfig allow us to interface with this instance.\r\n         */\r\n        var instance;\r\n        /**\r\n         * Manages the subscriptions for a visual element's lifecycle, for instance\r\n         * onRender\r\n         */\r\n        var lifecycles = createLifecycles();\r\n        /**\r\n         * A map of all motion values attached to this visual element. Motion\r\n         * values are source of truth for any given animated value. A motion\r\n         * value might be provided externally by the component via props.\r\n         */\r\n        var values = new Map();\r\n        /**\r\n         * A map of every subscription that binds the provided or generated\r\n         * motion values onChange listeners to this visual element.\r\n         */\r\n        var valueSubscriptions = new Map();\r\n        /**\r\n         * A reference to the previously-provided motion values as returned\r\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n         * if any motion values need to be removed after props are updated.\r\n         */\r\n        var prevMotionValues = {};\r\n        /**\r\n         * When values are removed from all animation props we need to search\r\n         * for a fallback value to animate to. These values are tracked in baseTarget.\r\n         */\r\n        var baseTarget = __assign({}, latestValues);\r\n        // Internal methods ========================\r\n        /**\r\n         * On mount, this will be hydrated with a callback to disconnect\r\n         * this visual element from its parent on unmount.\r\n         */\r\n        var removeFromVariantTree;\r\n        /**\r\n         * Render the element with the latest styles outside of the React\r\n         * render lifecycle\r\n         */\r\n        function render() {\r\n            if (!instance || !isMounted)\r\n                return;\r\n            triggerBuild();\r\n            renderInstance(instance, renderState, props.style, element.projection);\r\n        }\r\n        function triggerBuild() {\r\n            build(element, renderState, latestValues, options, props);\r\n        }\r\n        function update() {\r\n            lifecycles.notifyUpdate(latestValues);\r\n        }\r\n        /**\r\n         *\r\n         */\r\n        function bindToMotionValue(key, value) {\r\n            var removeOnChange = value.onChange(function (latestValue) {\r\n                latestValues[key] = latestValue;\r\n                props.onUpdate && sync.update(update, false, true);\r\n            });\r\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\r\n            valueSubscriptions.set(key, function () {\r\n                removeOnChange();\r\n                removeOnRenderRequest();\r\n            });\r\n        }\r\n        /**\r\n         * Any motion values that are provided to the element when created\r\n         * aren't yet bound to the element, as this would technically be impure.\r\n         * However, we iterate through the motion values and set them to the\r\n         * initial values for this component.\r\n         *\r\n         * TODO: This is impure and we should look at changing this to run on mount.\r\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\r\n         * more a reflection of the test.\r\n         */\r\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\r\n        for (var key in initialMotionValues) {\r\n            var value = initialMotionValues[key];\r\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\r\n                value.set(latestValues[key], false);\r\n            }\r\n        }\r\n        /**\r\n         * Determine what role this visual element should take in the variant tree.\r\n         */\r\n        var isControllingVariants = checkIfControllingVariants(props);\r\n        var isVariantNode = checkIfVariantNode(props);\r\n        var element = __assign(__assign({ treeType: treeType, \r\n            /**\r\n             * This is a mirror of the internal instance prop, which keeps\r\n             * VisualElement type-compatible with React's RefObject.\r\n             */\r\n            current: null, \r\n            /**\r\n             * The depth of this visual element within the visual element tree.\r\n             */\r\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \r\n            /**\r\n             *\r\n             */\r\n            presenceId: presenceId, shouldReduceMotion: shouldReduceMotion, \r\n            /**\r\n             * If this component is part of the variant tree, it should track\r\n             * any children that are also part of the tree. This is essentially\r\n             * a shadow tree to simplify logic around how to stagger over children.\r\n             */\r\n            variantChildren: isVariantNode ? new Set() : undefined, \r\n            /**\r\n             * Whether this instance is visible. This can be changed imperatively\r\n             * by the projection tree, is analogous to CSS's visibility in that\r\n             * hidden elements should take up layout, and needs enacting by the configured\r\n             * render function.\r\n             */\r\n            isVisible: undefined, \r\n            /**\r\n             * Normally, if a component is controlled by a parent's variants, it can\r\n             * rely on that ancestor to trigger animations further down the tree.\r\n             * However, if a component is created after its parent is mounted, the parent\r\n             * won't trigger that mount animation so the child needs to.\r\n             *\r\n             * TODO: This might be better replaced with a method isParentMounted\r\n             */\r\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \r\n            /**\r\n             * This can be set by AnimatePresence to force components that mount\r\n             * at the same time as it to mount as if they have initial={false} set.\r\n             */\r\n            blockInitialAnimation: blockInitialAnimation, \r\n            /**\r\n             * Determine whether this component has mounted yet. This is mostly used\r\n             * by variant children to determine whether they need to trigger their\r\n             * own animations on mount.\r\n             */\r\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\r\n                isMounted = true;\r\n                instance = element.current = newInstance;\r\n                if (element.projection) {\r\n                    element.projection.mount(newInstance);\r\n                }\r\n                if (isVariantNode && parent && !isControllingVariants) {\r\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\r\n                }\r\n                values.forEach(function (value, key) { return bindToMotionValue(key, value); });\r\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\r\n                element.setProps(props);\r\n            }, \r\n            /**\r\n             *\r\n             */\r\n            unmount: function () {\r\n                var _a;\r\n                (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\r\n                cancelSync.update(update);\r\n                cancelSync.render(render);\r\n                valueSubscriptions.forEach(function (remove) { return remove(); });\r\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\r\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\r\n                lifecycles.clearAllListeners();\r\n                instance = undefined;\r\n                isMounted = false;\r\n            }, \r\n            /**\r\n             * Add a child visual element to our set of children.\r\n             */\r\n            addVariantChild: function (child) {\r\n                var _a;\r\n                var closestVariantNode = element.getClosestVariantNode();\r\n                if (closestVariantNode) {\r\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\r\n                    return function () {\r\n                        return closestVariantNode.variantChildren.delete(child);\r\n                    };\r\n                }\r\n            }, sortNodePosition: function (other) {\r\n                /**\r\n                 * If these nodes aren't even of the same type we can't compare their depth.\r\n                 */\r\n                if (!sortNodePosition || treeType !== other.treeType)\r\n                    return 0;\r\n                return sortNodePosition(element.getInstance(), other.getInstance());\r\n            }, \r\n            /**\r\n             * Returns the closest variant node in the tree starting from\r\n             * this visual element.\r\n             */\r\n            getClosestVariantNode: function () {\r\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\r\n            }, \r\n            /**\r\n             * Expose the latest layoutId prop.\r\n             */\r\n            getLayoutId: function () { return props.layoutId; }, \r\n            /**\r\n             * Returns the current instance.\r\n             */\r\n            getInstance: function () { return instance; }, \r\n            /**\r\n             * Get/set the latest static values.\r\n             */\r\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \r\n            /**\r\n             * Returns the latest motion value state. Currently only used to take\r\n             * a snapshot of the visual element - perhaps this can return the whole\r\n             * visual state\r\n             */\r\n            getLatestValues: function () { return latestValues; }, \r\n            /**\r\n             * Set the visiblity of the visual element. If it's changed, schedule\r\n             * a render to reflect these changes.\r\n             */\r\n            setVisibility: function (visibility) {\r\n                if (element.isVisible === visibility)\r\n                    return;\r\n                element.isVisible = visibility;\r\n                element.scheduleRender();\r\n            }, \r\n            /**\r\n             * Make a target animatable by Popmotion. For instance, if we're\r\n             * trying to animate width from 100px to 100vw we need to measure 100vw\r\n             * in pixels to determine what we really need to animate to. This is also\r\n             * pluggable to support Framer's custom value types like Color,\r\n             * and CSS variables.\r\n             */\r\n            makeTargetAnimatable: function (target, canMutate) {\r\n                if (canMutate === void 0) { canMutate = true; }\r\n                return makeTargetAnimatable(element, target, props, canMutate);\r\n            }, \r\n            /**\r\n             * Measure the current viewport box with or without transforms.\r\n             * Only measures axis-aligned boxes, rotate and skew must be manually\r\n             * removed with a re-render to work.\r\n             */\r\n            measureViewportBox: function () {\r\n                return measureViewportBox(instance, props);\r\n            }, \r\n            // Motion values ========================\r\n            /**\r\n             * Add a motion value and bind it to this visual element.\r\n             */\r\n            addValue: function (key, value) {\r\n                // Remove existing value if it exists\r\n                if (element.hasValue(key))\r\n                    element.removeValue(key);\r\n                values.set(key, value);\r\n                latestValues[key] = value.get();\r\n                bindToMotionValue(key, value);\r\n            }, \r\n            /**\r\n             * Remove a motion value and unbind any active subscriptions.\r\n             */\r\n            removeValue: function (key) {\r\n                var _a;\r\n                values.delete(key);\r\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\r\n                valueSubscriptions.delete(key);\r\n                delete latestValues[key];\r\n                removeValueFromRenderState(key, renderState);\r\n            }, \r\n            /**\r\n             * Check whether we have a motion value for this key\r\n             */\r\n            hasValue: function (key) { return values.has(key); }, \r\n            /**\r\n             * Get a motion value for this key. If called with a default\r\n             * value, we'll create one if none exists.\r\n             */\r\n            getValue: function (key, defaultValue) {\r\n                var value = values.get(key);\r\n                if (value === undefined && defaultValue !== undefined) {\r\n                    value = motionValue(defaultValue);\r\n                    element.addValue(key, value);\r\n                }\r\n                return value;\r\n            }, \r\n            /**\r\n             * Iterate over our motion values.\r\n             */\r\n            forEachValue: function (callback) { return values.forEach(callback); }, \r\n            /**\r\n             * If we're trying to animate to a previously unencountered value,\r\n             * we need to check for it in our state and as a last resort read it\r\n             * directly from the instance (which might have performance implications).\r\n             */\r\n            readValue: function (key) {\r\n                var _a;\r\n                return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\r\n            }, \r\n            /**\r\n             * Set the base target to later animate back to. This is currently\r\n             * only hydrated on creation and when we first read a value.\r\n             */\r\n            setBaseTarget: function (key, value) {\r\n                baseTarget[key] = value;\r\n            }, \r\n            /**\r\n             * Find the base target for a value thats been removed from all animation\r\n             * props.\r\n             */\r\n            getBaseTarget: function (key) {\r\n                if (getBaseTarget) {\r\n                    var target = getBaseTarget(props, key);\r\n                    if (target !== undefined && !isMotionValue(target))\r\n                        return target;\r\n                }\r\n                return baseTarget[key];\r\n            } }, lifecycles), { \r\n            /**\r\n             * Build the renderer state based on the latest visual state.\r\n             */\r\n            build: function () {\r\n                triggerBuild();\r\n                return renderState;\r\n            }, \r\n            /**\r\n             * Schedule a render on the next animation frame.\r\n             */\r\n            scheduleRender: function () {\r\n                sync.render(render, false, true);\r\n            }, \r\n            /**\r\n             * Synchronously fire render. It's prefered that we batch renders but\r\n             * in many circumstances, like layout measurement, we need to run this\r\n             * synchronously. However in those instances other measures should be taken\r\n             * to batch reads/writes.\r\n             */\r\n            syncRender: render, \r\n            /**\r\n             * Update the provided props. Ensure any newly-added motion values are\r\n             * added to our map, old ones removed, and listeners updated.\r\n             */\r\n            setProps: function (newProps) {\r\n                if (newProps.transformTemplate || props.transformTemplate) {\r\n                    element.scheduleRender();\r\n                }\r\n                props = newProps;\r\n                lifecycles.updatePropListeners(newProps);\r\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\r\n            }, getProps: function () { return props; }, \r\n            // Variants ==============================\r\n            /**\r\n             * Returns the variant definition with a given name.\r\n             */\r\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \r\n            /**\r\n             * Returns the defined default transition on this component.\r\n             */\r\n            getDefaultTransition: function () { return props.transition; }, getTransformPagePoint: function () {\r\n                return props.transformPagePoint;\r\n            }, \r\n            /**\r\n             * Used by child variant nodes to get the closest ancestor variant props.\r\n             */\r\n            getVariantContext: function (startAtParent) {\r\n                if (startAtParent === void 0) { startAtParent = false; }\r\n                if (startAtParent)\r\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\r\n                if (!isControllingVariants) {\r\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\r\n                    if (props.initial !== undefined) {\r\n                        context_1.initial = props.initial;\r\n                    }\r\n                    return context_1;\r\n                }\r\n                var context = {};\r\n                for (var i = 0; i < numVariantProps; i++) {\r\n                    var name_1 = variantProps[i];\r\n                    var prop = props[name_1];\r\n                    if (isVariantLabel(prop) || prop === false) {\r\n                        context[name_1] = prop;\r\n                    }\r\n                }\r\n                return context;\r\n            } });\r\n        return element;\r\n    };\r\n};\r\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder), false);\r\nvar numVariantProps = variantProps.length;\r\n\r\nexport { visualElement };\r\n"]},"metadata":{},"sourceType":"module"}