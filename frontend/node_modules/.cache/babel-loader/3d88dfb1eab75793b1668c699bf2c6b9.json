{"ast":null,"code":"import { __assign, __read } from 'tslib';\nimport { number, px } from 'style-value-types';\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from 'hey-listen';\nimport { transformProps } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function (v) {\n  return v === number || v === px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.syncRender();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function (_a, _b) {\n    var x = _a.x;\n    var _c = _b.paddingLeft,\n        paddingLeft = _c === void 0 ? \"0\" : _c,\n        _d = _b.paddingRight,\n        paddingRight = _d === void 0 ? \"0\" : _d;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: function (_a, _b) {\n    var y = _a.y;\n    var _c = _b.paddingTop,\n        paddingTop = _c === void 0 ? \"0\" : _c,\n        _d = _b.paddingBottom,\n        paddingBottom = _d === void 0 ? \"0\" : _d;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display;\n  var origin = {}; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\r\n   * Record origins before we render and update styles\r\n   */\n\n\n  changedKeys.forEach(function (key) {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  }); // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n  visualElement.syncRender();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var fromType = findDimensionValueType(from);\n    var to = target[key];\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n      var fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n\n      for (var i = fromIndex; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var _b = __read(_a, 2),\n            key = _b[0],\n            value = _b[1];\n\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.syncRender();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nexport { BoundingBoxDimension, positionalValues, unitConversion };","map":{"version":3,"sources":["C:/Users/jeswa/Documents/online-clipboard/frontend/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"names":["__assign","__read","number","px","isKeyframesTarget","invariant","transformProps","findDimensionValueType","positionalKeys","Set","isPositionalKey","key","has","hasPositionalKey","target","Object","keys","some","setAndResetVelocity","value","to","set","isNumOrPxType","v","BoundingBoxDimension","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","_a","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","getValue","undefined","push","get","startsWith","length","syncRender","positionalValues","width","_b","x","_c","paddingLeft","_d","paddingRight","max","min","height","y","paddingTop","paddingBottom","top","left","bottom","right","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","element","getInstance","elementComputedStyle","getComputedStyle","display","origin","setStaticValue","targetBbox","checkAndConvertChangedValueTypes","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","hasValue","from","fromType","toType","numKeyframes","fromIndex","i","current","Array","isArray","map","convertedTarget","unitConversion"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,MAAnB,QAAiC,OAAjC;AACA,SAASC,MAAT,EAAiBC,EAAjB,QAA2B,mBAA3B;AACA,SAASC,iBAAT,QAAkC,kDAAlC;AACA,SAASC,SAAT,QAA0B,YAA1B;AACA,SAASC,cAAT,QAA+B,gCAA/B;AACA,SAASC,sBAAT,QAAuC,+BAAvC;AAEA,IAAIC,cAAc,GAAG,IAAIC,GAAJ,CAAQ,CACzB,OADyB,EAEzB,QAFyB,EAGzB,KAHyB,EAIzB,MAJyB,EAKzB,OALyB,EAMzB,QANyB,EAOzB,GAPyB,EAQzB,GARyB,CAAR,CAArB;;AAUA,IAAIC,eAAe,GAAG,UAAUC,GAAV,EAAe;AAAE,SAAOH,cAAc,CAACI,GAAf,CAAmBD,GAAnB,CAAP;AAAiC,CAAxE;;AACA,IAAIE,gBAAgB,GAAG,UAAUC,MAAV,EAAkB;AACrC,SAAOC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBG,IAApB,CAAyBP,eAAzB,CAAP;AACH,CAFD;;AAGA,IAAIQ,mBAAmB,GAAG,UAAUC,KAAV,EAAiBC,EAAjB,EAAqB;AAC3C;AACA;AACAD,EAAAA,KAAK,CAACE,GAAN,CAAUD,EAAV,EAAc,KAAd;AACAD,EAAAA,KAAK,CAACE,GAAN,CAAUD,EAAV;AACH,CALD;;AAMA,IAAIE,aAAa,GAAG,UAAUC,CAAV,EAAa;AAC7B,SAAOA,CAAC,KAAKrB,MAAN,IAAgBqB,CAAC,KAAKpB,EAA7B;AACH,CAFD;;AAGA,IAAIqB,oBAAJ;;AACA,CAAC,UAAUA,oBAAV,EAAgC;AAC7BA,EAAAA,oBAAoB,CAAC,OAAD,CAApB,GAAgC,OAAhC;AACAA,EAAAA,oBAAoB,CAAC,QAAD,CAApB,GAAiC,QAAjC;AACAA,EAAAA,oBAAoB,CAAC,MAAD,CAApB,GAA+B,MAA/B;AACAA,EAAAA,oBAAoB,CAAC,OAAD,CAApB,GAAgC,OAAhC;AACAA,EAAAA,oBAAoB,CAAC,KAAD,CAApB,GAA8B,KAA9B;AACAA,EAAAA,oBAAoB,CAAC,QAAD,CAApB,GAAiC,QAAjC;AACH,CAPD,EAOGA,oBAAoB,KAAKA,oBAAoB,GAAG,EAA5B,CAPvB;;AAQA,IAAIC,gBAAgB,GAAG,UAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AAC1C,SAAOC,UAAU,CAACF,MAAM,CAACG,KAAP,CAAa,IAAb,EAAmBF,GAAnB,CAAD,CAAjB;AACH,CAFD;;AAGA,IAAIG,sBAAsB,GAAG,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AAC/C,SAAO,UAAUC,KAAV,EAAiBC,EAAjB,EAAqB;AACxB,QAAIC,SAAS,GAAGD,EAAE,CAACC,SAAnB;AACA,QAAIA,SAAS,KAAK,MAAd,IAAwB,CAACA,SAA7B,EACI,OAAO,CAAP;AACJ,QAAIC,QAAQ,GAAGD,SAAS,CAACE,KAAV,CAAgB,oBAAhB,CAAf;;AACA,QAAID,QAAJ,EAAc;AACV,aAAOX,gBAAgB,CAACW,QAAQ,CAAC,CAAD,CAAT,EAAcJ,IAAd,CAAvB;AACH,KAFD,MAGK;AACD,UAAIN,MAAM,GAAGS,SAAS,CAACE,KAAV,CAAgB,kBAAhB,CAAb;;AACA,UAAIX,MAAJ,EAAY;AACR,eAAOD,gBAAgB,CAACC,MAAM,CAAC,CAAD,CAAP,EAAYK,IAAZ,CAAvB;AACH,OAFD,MAGK;AACD,eAAO,CAAP;AACH;AACJ;AACJ,GAjBD;AAkBH,CAnBD;;AAoBA,IAAIO,aAAa,GAAG,IAAI7B,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAR,CAApB;AACA,IAAI8B,6BAA6B,GAAGjC,cAAc,CAACkC,MAAf,CAAsB,UAAU7B,GAAV,EAAe;AAAE,SAAO,CAAC2B,aAAa,CAAC1B,GAAd,CAAkBD,GAAlB,CAAR;AAAiC,CAAxE,CAApC;;AACA,SAAS8B,+BAAT,CAAyCC,aAAzC,EAAwD;AACpD,MAAIC,iBAAiB,GAAG,EAAxB;AACAJ,EAAAA,6BAA6B,CAACK,OAA9B,CAAsC,UAAUjC,GAAV,EAAe;AACjD,QAAIQ,KAAK,GAAGuB,aAAa,CAACG,QAAd,CAAuBlC,GAAvB,CAAZ;;AACA,QAAIQ,KAAK,KAAK2B,SAAd,EAAyB;AACrBH,MAAAA,iBAAiB,CAACI,IAAlB,CAAuB,CAACpC,GAAD,EAAMQ,KAAK,CAAC6B,GAAN,EAAN,CAAvB;AACA7B,MAAAA,KAAK,CAACE,GAAN,CAAUV,GAAG,CAACsC,UAAJ,CAAe,OAAf,IAA0B,CAA1B,GAA8B,CAAxC;AACH;AACJ,GAND,EAFoD,CASpD;;AACA,MAAIN,iBAAiB,CAACO,MAAtB,EACIR,aAAa,CAACS,UAAd;AACJ,SAAOR,iBAAP;AACH;;AACD,IAAIS,gBAAgB,GAAG;AACnB;AACAC,EAAAA,KAAK,EAAE,UAAUnB,EAAV,EAAcoB,EAAd,EAAkB;AACrB,QAAIC,CAAC,GAAGrB,EAAE,CAACqB,CAAX;AACA,QAAIC,EAAE,GAAGF,EAAE,CAACG,WAAZ;AAAA,QAAyBA,WAAW,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,GAAhB,GAAsBA,EAA7D;AAAA,QAAiEE,EAAE,GAAGJ,EAAE,CAACK,YAAzE;AAAA,QAAuFA,YAAY,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,GAAhB,GAAsBA,EAA5H;AACA,WAAOH,CAAC,CAACK,GAAF,GAAQL,CAAC,CAACM,GAAV,GAAgBjC,UAAU,CAAC6B,WAAD,CAA1B,GAA0C7B,UAAU,CAAC+B,YAAD,CAA3D;AACH,GANkB;AAOnBG,EAAAA,MAAM,EAAE,UAAU5B,EAAV,EAAcoB,EAAd,EAAkB;AACtB,QAAIS,CAAC,GAAG7B,EAAE,CAAC6B,CAAX;AACA,QAAIP,EAAE,GAAGF,EAAE,CAACU,UAAZ;AAAA,QAAwBA,UAAU,GAAGR,EAAE,KAAK,KAAK,CAAZ,GAAgB,GAAhB,GAAsBA,EAA3D;AAAA,QAA+DE,EAAE,GAAGJ,EAAE,CAACW,aAAvE;AAAA,QAAsFA,aAAa,GAAGP,EAAE,KAAK,KAAK,CAAZ,GAAgB,GAAhB,GAAsBA,EAA5H;AACA,WAAOK,CAAC,CAACH,GAAF,GAAQG,CAAC,CAACF,GAAV,GAAgBjC,UAAU,CAACoC,UAAD,CAA1B,GAAyCpC,UAAU,CAACqC,aAAD,CAA1D;AACH,GAXkB;AAYnBC,EAAAA,GAAG,EAAE,UAAUjC,KAAV,EAAiBC,EAAjB,EAAqB;AACtB,QAAIgC,GAAG,GAAGhC,EAAE,CAACgC,GAAb;AACA,WAAOtC,UAAU,CAACsC,GAAD,CAAjB;AACH,GAfkB;AAgBnBC,EAAAA,IAAI,EAAE,UAAUlC,KAAV,EAAiBC,EAAjB,EAAqB;AACvB,QAAIiC,IAAI,GAAGjC,EAAE,CAACiC,IAAd;AACA,WAAOvC,UAAU,CAACuC,IAAD,CAAjB;AACH,GAnBkB;AAoBnBC,EAAAA,MAAM,EAAE,UAAUlC,EAAV,EAAcoB,EAAd,EAAkB;AACtB,QAAIS,CAAC,GAAG7B,EAAE,CAAC6B,CAAX;AACA,QAAIG,GAAG,GAAGZ,EAAE,CAACY,GAAb;AACA,WAAOtC,UAAU,CAACsC,GAAD,CAAV,IAAmBH,CAAC,CAACH,GAAF,GAAQG,CAAC,CAACF,GAA7B,CAAP;AACH,GAxBkB;AAyBnBQ,EAAAA,KAAK,EAAE,UAAUnC,EAAV,EAAcoB,EAAd,EAAkB;AACrB,QAAIC,CAAC,GAAGrB,EAAE,CAACqB,CAAX;AACA,QAAIY,IAAI,GAAGb,EAAE,CAACa,IAAd;AACA,WAAOvC,UAAU,CAACuC,IAAD,CAAV,IAAoBZ,CAAC,CAACK,GAAF,GAAQL,CAAC,CAACM,GAA9B,CAAP;AACH,GA7BkB;AA8BnB;AACAN,EAAAA,CAAC,EAAEzB,sBAAsB,CAAC,CAAD,EAAI,EAAJ,CA/BN;AAgCnBiC,EAAAA,CAAC,EAAEjC,sBAAsB,CAAC,CAAD,EAAI,EAAJ;AAhCN,CAAvB;;AAkCA,IAAIwC,wBAAwB,GAAG,UAAUxD,MAAV,EAAkB4B,aAAlB,EAAiC6B,WAAjC,EAA8C;AACzE,MAAIC,UAAU,GAAG9B,aAAa,CAAC+B,kBAAd,EAAjB;AACA,MAAIC,OAAO,GAAGhC,aAAa,CAACiC,WAAd,EAAd;AACA,MAAIC,oBAAoB,GAAGC,gBAAgB,CAACH,OAAD,CAA3C;AACA,MAAII,OAAO,GAAGF,oBAAoB,CAACE,OAAnC;AACA,MAAIC,MAAM,GAAG,EAAb,CALyE,CAMzE;AACA;;AACA,MAAID,OAAO,KAAK,MAAhB,EAAwB;AACpBpC,IAAAA,aAAa,CAACsC,cAAd,CAA6B,SAA7B,EAAwClE,MAAM,CAACgE,OAAP,IAAkB,OAA1D;AACH;AACD;AACJ;AACA;;;AACIP,EAAAA,WAAW,CAAC3B,OAAZ,CAAoB,UAAUjC,GAAV,EAAe;AAC/BoE,IAAAA,MAAM,CAACpE,GAAD,CAAN,GAAcyC,gBAAgB,CAACzC,GAAD,CAAhB,CAAsB6D,UAAtB,EAAkCI,oBAAlC,CAAd;AACH,GAFD,EAdyE,CAiBzE;;AACAlC,EAAAA,aAAa,CAACS,UAAd;AACA,MAAI8B,UAAU,GAAGvC,aAAa,CAAC+B,kBAAd,EAAjB;AACAF,EAAAA,WAAW,CAAC3B,OAAZ,CAAoB,UAAUjC,GAAV,EAAe;AAC/B;AACA;AACA,QAAIQ,KAAK,GAAGuB,aAAa,CAACG,QAAd,CAAuBlC,GAAvB,CAAZ;AACAO,IAAAA,mBAAmB,CAACC,KAAD,EAAQ4D,MAAM,CAACpE,GAAD,CAAd,CAAnB;AACAG,IAAAA,MAAM,CAACH,GAAD,CAAN,GAAcyC,gBAAgB,CAACzC,GAAD,CAAhB,CAAsBsE,UAAtB,EAAkCL,oBAAlC,CAAd;AACH,GAND;AAOA,SAAO9D,MAAP;AACH,CA5BD;;AA6BA,IAAIoE,gCAAgC,GAAG,UAAUxC,aAAV,EAAyB5B,MAAzB,EAAiCiE,MAAjC,EAAyCI,aAAzC,EAAwD;AAC3F,MAAIJ,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAG,EAAT;AAAc;;AACvC,MAAII,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,IAAAA,aAAa,GAAG,EAAhB;AAAqB;;AACrDrE,EAAAA,MAAM,GAAGd,QAAQ,CAAC,EAAD,EAAKc,MAAL,CAAjB;AACAqE,EAAAA,aAAa,GAAGnF,QAAQ,CAAC,EAAD,EAAKmF,aAAL,CAAxB;AACA,MAAIC,oBAAoB,GAAGrE,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoB0B,MAApB,CAA2B9B,eAA3B,CAA3B,CAL2F,CAM3F;AACA;;AACA,MAAI2E,sBAAsB,GAAG,EAA7B;AACA,MAAIC,mCAAmC,GAAG,KAA1C;AACA,MAAIC,oBAAoB,GAAG,EAA3B;AACAH,EAAAA,oBAAoB,CAACxC,OAArB,CAA6B,UAAUjC,GAAV,EAAe;AACxC,QAAIQ,KAAK,GAAGuB,aAAa,CAACG,QAAd,CAAuBlC,GAAvB,CAAZ;AACA,QAAI,CAAC+B,aAAa,CAAC8C,QAAd,CAAuB7E,GAAvB,CAAL,EACI;AACJ,QAAI8E,IAAI,GAAGV,MAAM,CAACpE,GAAD,CAAjB;AACA,QAAI+E,QAAQ,GAAGnF,sBAAsB,CAACkF,IAAD,CAArC;AACA,QAAIrE,EAAE,GAAGN,MAAM,CAACH,GAAD,CAAf;AACA,QAAIgF,MAAJ,CAPwC,CAQxC;AACA;AACA;AACA;;AACA,QAAIvF,iBAAiB,CAACgB,EAAD,CAArB,EAA2B;AACvB,UAAIwE,YAAY,GAAGxE,EAAE,CAAC8B,MAAtB;AACA,UAAI2C,SAAS,GAAGzE,EAAE,CAAC,CAAD,CAAF,KAAU,IAAV,GAAiB,CAAjB,GAAqB,CAArC;AACAqE,MAAAA,IAAI,GAAGrE,EAAE,CAACyE,SAAD,CAAT;AACAH,MAAAA,QAAQ,GAAGnF,sBAAsB,CAACkF,IAAD,CAAjC;;AACA,WAAK,IAAIK,CAAC,GAAGD,SAAb,EAAwBC,CAAC,GAAGF,YAA5B,EAA0CE,CAAC,EAA3C,EAA+C;AAC3C,YAAI,CAACH,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAGpF,sBAAsB,CAACa,EAAE,CAAC0E,CAAD,CAAH,CAA/B;AACAzF,UAAAA,SAAS,CAACsF,MAAM,KAAKD,QAAX,IACLpE,aAAa,CAACoE,QAAD,CAAb,IAA2BpE,aAAa,CAACqE,MAAD,CADpC,EAC+C,8DAD/C,CAAT;AAEH,SAJD,MAKK;AACDtF,UAAAA,SAAS,CAACE,sBAAsB,CAACa,EAAE,CAAC0E,CAAD,CAAH,CAAtB,KAAkCH,MAAnC,EAA2C,wCAA3C,CAAT;AACH;AACJ;AACJ,KAfD,MAgBK;AACDA,MAAAA,MAAM,GAAGpF,sBAAsB,CAACa,EAAD,CAA/B;AACH;;AACD,QAAIsE,QAAQ,KAAKC,MAAjB,EAAyB;AACrB;AACA;AACA,UAAIrE,aAAa,CAACoE,QAAD,CAAb,IAA2BpE,aAAa,CAACqE,MAAD,CAA5C,EAAsD;AAClD,YAAII,OAAO,GAAG5E,KAAK,CAAC6B,GAAN,EAAd;;AACA,YAAI,OAAO+C,OAAP,KAAmB,QAAvB,EAAiC;AAC7B5E,UAAAA,KAAK,CAACE,GAAN,CAAUO,UAAU,CAACmE,OAAD,CAApB;AACH;;AACD,YAAI,OAAO3E,EAAP,KAAc,QAAlB,EAA4B;AACxBN,UAAAA,MAAM,CAACH,GAAD,CAAN,GAAciB,UAAU,CAACR,EAAD,CAAxB;AACH,SAFD,MAGK,IAAI4E,KAAK,CAACC,OAAN,CAAc7E,EAAd,KAAqBuE,MAAM,KAAKxF,EAApC,EAAwC;AACzCW,UAAAA,MAAM,CAACH,GAAD,CAAN,GAAcS,EAAE,CAAC8E,GAAH,CAAOtE,UAAP,CAAd;AACH;AACJ,OAXD,MAYK,IAAI,CAAC8D,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACvD,SAA9D,MACJwD,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACxD,SADnD,MAEJsD,IAAI,KAAK,CAAT,IAAcrE,EAAE,KAAK,CAFjB,CAAJ,EAEyB;AAC1B;AACA;AACA,YAAIqE,IAAI,KAAK,CAAb,EAAgB;AACZtE,UAAAA,KAAK,CAACE,GAAN,CAAUsE,MAAM,CAACxD,SAAP,CAAiBsD,IAAjB,CAAV;AACH,SAFD,MAGK;AACD3E,UAAAA,MAAM,CAACH,GAAD,CAAN,GAAc+E,QAAQ,CAACvD,SAAT,CAAmBf,EAAnB,CAAd;AACH;AACJ,OAXI,MAYA;AACD;AACA;AACA,YAAI,CAACkE,mCAAL,EAA0C;AACtCD,UAAAA,sBAAsB,GAClB5C,+BAA+B,CAACC,aAAD,CADnC;AAEA4C,UAAAA,mCAAmC,GAAG,IAAtC;AACH;;AACDC,QAAAA,oBAAoB,CAACxC,IAArB,CAA0BpC,GAA1B;AACAwE,QAAAA,aAAa,CAACxE,GAAD,CAAb,GACIwE,aAAa,CAACxE,GAAD,CAAb,KAAuBmC,SAAvB,GACMqC,aAAa,CAACxE,GAAD,CADnB,GAEMG,MAAM,CAACH,GAAD,CAHhB;AAIAO,QAAAA,mBAAmB,CAACC,KAAD,EAAQC,EAAR,CAAnB;AACH;AACJ;AACJ,GA1ED;;AA2EA,MAAImE,oBAAoB,CAACrC,MAAzB,EAAiC;AAC7B,QAAIiD,eAAe,GAAG7B,wBAAwB,CAACxD,MAAD,EAAS4B,aAAT,EAAwB6C,oBAAxB,CAA9C,CAD6B,CAE7B;;AACA,QAAIF,sBAAsB,CAACnC,MAA3B,EAAmC;AAC/BmC,MAAAA,sBAAsB,CAACzC,OAAvB,CAA+B,UAAUV,EAAV,EAAc;AACzC,YAAIoB,EAAE,GAAGrD,MAAM,CAACiC,EAAD,EAAK,CAAL,CAAf;AAAA,YAAwBvB,GAAG,GAAG2C,EAAE,CAAC,CAAD,CAAhC;AAAA,YAAqCnC,KAAK,GAAGmC,EAAE,CAAC,CAAD,CAA/C;;AACAZ,QAAAA,aAAa,CAACG,QAAd,CAAuBlC,GAAvB,EAA4BU,GAA5B,CAAgCF,KAAhC;AACH,OAHD;AAIH,KAR4B,CAS7B;;;AACAuB,IAAAA,aAAa,CAACS,UAAd;AACA,WAAO;AAAErC,MAAAA,MAAM,EAAEqF,eAAV;AAA2BhB,MAAAA,aAAa,EAAEA;AAA1C,KAAP;AACH,GAZD,MAaK;AACD,WAAO;AAAErE,MAAAA,MAAM,EAAEA,MAAV;AAAkBqE,MAAAA,aAAa,EAAEA;AAAjC,KAAP;AACH;AACJ,CAtGD;AAuGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiB,cAAT,CAAwB1D,aAAxB,EAAuC5B,MAAvC,EAA+CiE,MAA/C,EAAuDI,aAAvD,EAAsE;AAClE,SAAOtE,gBAAgB,CAACC,MAAD,CAAhB,GACDoE,gCAAgC,CAACxC,aAAD,EAAgB5B,MAAhB,EAAwBiE,MAAxB,EAAgCI,aAAhC,CAD/B,GAED;AAAErE,IAAAA,MAAM,EAAEA,MAAV;AAAkBqE,IAAAA,aAAa,EAAEA;AAAjC,GAFN;AAGH;;AAED,SAAS3D,oBAAT,EAA+B4B,gBAA/B,EAAiDgD,cAAjD","sourcesContent":["import { __assign, __read } from 'tslib';\r\nimport { number, px } from 'style-value-types';\r\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\r\nimport { invariant } from 'hey-listen';\r\nimport { transformProps } from '../../html/utils/transform.mjs';\r\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\r\n\r\nvar positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\r\nvar hasPositionalKey = function (target) {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nvar setAndResetVelocity = function (value, to) {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nvar isNumOrPxType = function (v) {\r\n    return v === number || v === px;\r\n};\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nvar getPosFromMatrix = function (matrix, pos) {\r\n    return parseFloat(matrix.split(\", \")[pos]);\r\n};\r\nvar getTranslateFromMatrix = function (pos2, pos3) {\r\n    return function (_bbox, _a) {\r\n        var transform = _a.transform;\r\n        if (transform === \"none\" || !transform)\r\n            return 0;\r\n        var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n        if (matrix3d) {\r\n            return getPosFromMatrix(matrix3d[1], pos3);\r\n        }\r\n        else {\r\n            var matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n            if (matrix) {\r\n                return getPosFromMatrix(matrix[1], pos2);\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n    };\r\n};\r\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    var removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        visualElement.syncRender();\r\n    return removedTransforms;\r\n}\r\nvar positionalValues = {\r\n    // Dimensions\r\n    width: function (_a, _b) {\r\n        var x = _a.x;\r\n        var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? \"0\" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? \"0\" : _d;\r\n        return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\r\n    },\r\n    height: function (_a, _b) {\r\n        var y = _a.y;\r\n        var _c = _b.paddingTop, paddingTop = _c === void 0 ? \"0\" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? \"0\" : _d;\r\n        return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\r\n    },\r\n    top: function (_bbox, _a) {\r\n        var top = _a.top;\r\n        return parseFloat(top);\r\n    },\r\n    left: function (_bbox, _a) {\r\n        var left = _a.left;\r\n        return parseFloat(left);\r\n    },\r\n    bottom: function (_a, _b) {\r\n        var y = _a.y;\r\n        var top = _b.top;\r\n        return parseFloat(top) + (y.max - y.min);\r\n    },\r\n    right: function (_a, _b) {\r\n        var x = _a.x;\r\n        var left = _b.left;\r\n        return parseFloat(left) + (x.max - x.min);\r\n    },\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\r\n    var originBbox = visualElement.measureViewportBox();\r\n    var element = visualElement.getInstance();\r\n    var elementComputedStyle = getComputedStyle(element);\r\n    var display = elementComputedStyle.display;\r\n    var origin = {};\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\r\n    }\r\n    /**\r\n     * Record origins before we render and update styles\r\n     */\r\n    changedKeys.forEach(function (key) {\r\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\r\n    });\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    visualElement.syncRender();\r\n    var targetBbox = visualElement.measureViewportBox();\r\n    changedKeys.forEach(function (key) {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        var value = visualElement.getValue(key);\r\n        setAndResetVelocity(value, origin[key]);\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\r\n    if (origin === void 0) { origin = {}; }\r\n    if (transitionEnd === void 0) { transitionEnd = {}; }\r\n    target = __assign({}, target);\r\n    transitionEnd = __assign({}, transitionEnd);\r\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    var removedTransformValues = [];\r\n    var hasAttemptedToRemoveTransformValues = false;\r\n    var changedValueTypeKeys = [];\r\n    targetPositionalKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (!visualElement.hasValue(key))\r\n            return;\r\n        var from = origin[key];\r\n        var fromType = findDimensionValueType(from);\r\n        var to = target[key];\r\n        var toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            var numKeyframes = to.length;\r\n            var fromIndex = to[0] === null ? 1 : 0;\r\n            from = to[fromIndex];\r\n            fromType = findDimensionValueType(from);\r\n            for (var i = fromIndex; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = findDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = findDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                var current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\r\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\r\n                (from === 0 || to === 0)) {\r\n                // If one or the other value is 0, it's safe to coerce it to the\r\n                // type of the other without measurement\r\n                if (from === 0) {\r\n                    value.set(toType.transform(from));\r\n                }\r\n                else {\r\n                    target[key] = fromType.transform(to);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues =\r\n                        removeNonTranslationalTransform(visualElement);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                changedValueTypeKeys.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n    });\r\n    if (changedValueTypeKeys.length) {\r\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(function (_a) {\r\n                var _b = __read(_a, 2), key = _b[0], value = _b[1];\r\n                visualElement.getValue(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        visualElement.syncRender();\r\n        return { target: convertedTarget, transitionEnd: transitionEnd };\r\n    }\r\n    else {\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\r\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\r\n        : { target: target, transitionEnd: transitionEnd };\r\n}\r\n\r\nexport { BoundingBoxDimension, positionalValues, unitConversion };\r\n"]},"metadata":{},"sourceType":"module"}