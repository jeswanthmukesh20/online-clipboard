{"ast":null,"code":"import { __read } from 'tslib';\nimport { mix } from 'popmotion';\nimport { hasTransform } from '../utils/has-transform.mjs';\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\n\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\r\n * Applies a translate/scale delta to a point\r\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\n\n\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Applies a translate/scale delta to a box\r\n */\n\n\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n      y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {\n  var _a, _b;\n\n  if (isSharedTransition === void 0) {\n    isSharedTransition = false;\n  }\n\n  var treeLength = treePath.length;\n  if (!treeLength) return; // Reset the treeScale\n\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta;\n\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\") continue;\n\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.x,\n        y: -node.scroll.y\n      });\n    }\n\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale; // Apply each ancestor's calculated delta into this component's recorded layout box\n\n      applyBoxDelta(box, delta);\n    }\n\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n}\n\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\n\n\nfunction transformAxis(axis, transforms, _a) {\n  var _b = __read(_a, 3),\n      key = _b[0],\n      scaleKey = _b[1],\n      originKey = _b[2];\n\n  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  var originPoint = mix(axis.min, axis.max, axisOrigin); // Apply the axis delta to the final axis\n\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\n\n\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\n\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };","map":{"version":3,"sources":["C:/Users/jeswa/Documents/online-clipboard/frontend/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"names":["__read","mix","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","_a","x","y","applyTreeDeltas","treeScale","treePath","isSharedTransition","_b","treeLength","length","node","delta","i","projectionDelta","instance","style","display","options","layoutScroll","scroll","root","transformBox","latestValues","translateAxis","distance","transformAxis","transforms","key","scaleKey","originKey","axisOrigin","xKeys","yKeys","transform"],"mappings":"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","sourcesContent":["import { __read } from 'tslib';\r\nimport { mix } from 'popmotion';\r\nimport { hasTransform } from '../utils/has-transform.mjs';\r\n\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    var distanceFromOrigin = point - originPoint;\r\n    var scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\r\n    if (translate === void 0) { translate = 0; }\r\n    if (scale === void 0) { scale = 1; }\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, _a) {\r\n    var x = _a.x, y = _a.y;\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {\r\n    var _a, _b;\r\n    if (isSharedTransition === void 0) { isSharedTransition = false; }\r\n    var treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    var node;\r\n    var delta;\r\n    for (var i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.projectionDelta;\r\n        if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\")\r\n            continue;\r\n        if (isSharedTransition &&\r\n            node.options.layoutScroll &&\r\n            node.scroll &&\r\n            node !== node.root) {\r\n            transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });\r\n        }\r\n        if (delta) {\r\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n            treeScale.x *= delta.x.scale;\r\n            treeScale.y *= delta.y.scale;\r\n            // Apply each ancestor's calculated delta into this component's recorded layout box\r\n            applyBoxDelta(box, delta);\r\n        }\r\n        if (isSharedTransition && hasTransform(node.latestValues)) {\r\n            transformBox(box, node.latestValues);\r\n        }\r\n    }\r\n}\r\nfunction translateAxis(axis, distance) {\r\n    axis.min = axis.min + distance;\r\n    axis.max = axis.max + distance;\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction transformAxis(axis, transforms, _a) {\r\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\r\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\r\n    var originPoint = mix(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\r\n}\r\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\r\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\r\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction transformBox(box, transform) {\r\n    transformAxis(box.x, transform, xKeys);\r\n    transformAxis(box.y, transform, yKeys);\r\n}\r\n\r\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\r\n"]},"metadata":{},"sourceType":"module"}