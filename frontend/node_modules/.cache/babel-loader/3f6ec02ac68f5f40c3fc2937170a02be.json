{"ast":null,"code":"import process from '../../../utils/process.mjs';\nimport { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nfunction useViewport(_a) {\n  var visualElement = _a.visualElement,\n      whileInView = _a.whileInView,\n      onViewportEnter = _a.onViewportEnter,\n      onViewportLeave = _a.onViewportLeave,\n      _b = _a.viewport,\n      viewport = _b === void 0 ? {} : _b;\n  var state = useRef({\n    hasEnteredView: false,\n    isInView: false\n  });\n  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n  var useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\n\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\n\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _a) {\n  var root = _a.root,\n      rootMargin = _a.margin,\n      _b = _a.amount,\n      amount = _b === void 0 ? \"some\" : _b,\n      once = _a.once;\n  useEffect(function () {\n    if (!shouldObserve) return;\n    var options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin: rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n\n    var intersectionCallback = function intersectionCallback(entry) {\n      var _a;\n\n      var isIntersecting = entry.isIntersecting;\n      /**\r\n       * If there's been no change in the viewport state, early return.\r\n       */\n\n      if (state.isInView === isIntersecting) return;\n      state.isInView = isIntersecting;\n      /**\r\n       * Handle hasEnteredView. If this is only meant to run once, and\r\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\r\n       */\n\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n\n      (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, isIntersecting);\n      /**\r\n       * Use the latest committed props rather than the ones in scope\r\n       * when this observer is created\r\n       */\n\n      var props = visualElement.getProps();\n      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback === null || callback === void 0 ? void 0 : callback(entry);\n    };\n\n    return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\r\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\r\n * on mount. This way, the page will be in the state the author expects users\r\n * to see it in for everyone.\r\n */\n\n\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {\n  var _b = _a.fallback,\n      fallback = _b === void 0 ? true : _b;\n  useEffect(function () {\n    if (!shouldObserve || !fallback) return;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    /**\r\n     * Fire this in an rAF because, at this point, the animation state\r\n     * won't have flushed for the first time and there's certain logic in\r\n     * there that behaves differently on the initial animation.\r\n     *\r\n     * This hook should be quite rarely called so setting this in an rAF\r\n     * is preferred to changing the behaviour of the animation state.\r\n     */\n\n\n    requestAnimationFrame(function () {\n      var _a;\n\n      state.hasEnteredView = true;\n      var onViewportEnter = visualElement.getProps().onViewportEnter;\n      onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);\n      (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, true);\n    });\n  }, [shouldObserve]);\n}\n\nexport { useViewport };","map":{"version":3,"sources":["C:/Users/jeswa/Documents/online-clipboard/frontend/node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs"],"names":["process","useRef","useEffect","AnimationType","warnOnce","observeIntersection","useViewport","_a","visualElement","whileInView","onViewportEnter","onViewportLeave","_b","viewport","state","hasEnteredView","isInView","shouldObserve","Boolean","once","current","useObserver","IntersectionObserver","useMissingIntersectionObserver","useIntersectionObserver","thresholdNames","some","all","root","rootMargin","margin","amount","options","threshold","intersectionCallback","entry","isIntersecting","animationState","setActive","InView","props","getProps","callback","getInstance","fallback","env","NODE_ENV","requestAnimationFrame"],"mappings":"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","sourcesContent":["import process from '../../../utils/process.mjs';\r\nimport { useRef, useEffect } from 'react';\r\nimport { AnimationType } from '../../../render/utils/types.mjs';\r\nimport { warnOnce } from '../../../utils/warn-once.mjs';\r\nimport { observeIntersection } from './observers.mjs';\r\n\r\nfunction useViewport(_a) {\r\n    var visualElement = _a.visualElement, whileInView = _a.whileInView, onViewportEnter = _a.onViewportEnter, onViewportLeave = _a.onViewportLeave, _b = _a.viewport, viewport = _b === void 0 ? {} : _b;\r\n    var state = useRef({\r\n        hasEnteredView: false,\r\n        isInView: false,\r\n    });\r\n    var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\r\n    if (viewport.once && state.current.hasEnteredView)\r\n        shouldObserve = false;\r\n    var useObserver = typeof IntersectionObserver === \"undefined\"\r\n        ? useMissingIntersectionObserver\r\n        : useIntersectionObserver;\r\n    useObserver(shouldObserve, state.current, visualElement, viewport);\r\n}\r\nvar thresholdNames = {\r\n    some: 0,\r\n    all: 1,\r\n};\r\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _a) {\r\n    var root = _a.root, rootMargin = _a.margin, _b = _a.amount, amount = _b === void 0 ? \"some\" : _b, once = _a.once;\r\n    useEffect(function () {\r\n        if (!shouldObserve)\r\n            return;\r\n        var options = {\r\n            root: root === null || root === void 0 ? void 0 : root.current,\r\n            rootMargin: rootMargin,\r\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\r\n        };\r\n        var intersectionCallback = function (entry) {\r\n            var _a;\r\n            var isIntersecting = entry.isIntersecting;\r\n            /**\r\n             * If there's been no change in the viewport state, early return.\r\n             */\r\n            if (state.isInView === isIntersecting)\r\n                return;\r\n            state.isInView = isIntersecting;\r\n            /**\r\n             * Handle hasEnteredView. If this is only meant to run once, and\r\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\r\n             */\r\n            if (once && !isIntersecting && state.hasEnteredView) {\r\n                return;\r\n            }\r\n            else if (isIntersecting) {\r\n                state.hasEnteredView = true;\r\n            }\r\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, isIntersecting);\r\n            /**\r\n             * Use the latest committed props rather than the ones in scope\r\n             * when this observer is created\r\n             */\r\n            var props = visualElement.getProps();\r\n            var callback = isIntersecting\r\n                ? props.onViewportEnter\r\n                : props.onViewportLeave;\r\n            callback === null || callback === void 0 ? void 0 : callback(entry);\r\n        };\r\n        return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\r\n    }, [shouldObserve, root, rootMargin, amount]);\r\n}\r\n/**\r\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\r\n * on mount. This way, the page will be in the state the author expects users\r\n * to see it in for everyone.\r\n */\r\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {\r\n    var _b = _a.fallback, fallback = _b === void 0 ? true : _b;\r\n    useEffect(function () {\r\n        if (!shouldObserve || !fallback)\r\n            return;\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\r\n        }\r\n        /**\r\n         * Fire this in an rAF because, at this point, the animation state\r\n         * won't have flushed for the first time and there's certain logic in\r\n         * there that behaves differently on the initial animation.\r\n         *\r\n         * This hook should be quite rarely called so setting this in an rAF\r\n         * is preferred to changing the behaviour of the animation state.\r\n         */\r\n        requestAnimationFrame(function () {\r\n            var _a;\r\n            state.hasEnteredView = true;\r\n            var onViewportEnter = visualElement.getProps().onViewportEnter;\r\n            onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);\r\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, true);\r\n        });\r\n    }, [shouldObserve]);\r\n}\r\n\r\nexport { useViewport };\r\n"]},"metadata":{},"sourceType":"module"}