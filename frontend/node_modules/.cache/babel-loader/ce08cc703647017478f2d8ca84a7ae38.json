{"ast":null,"code":"import { complex, color } from 'style-value-types';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { isNum } from './inc.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from 'hey-listen';\n\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return v => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\n\nconst mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n  return v => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n\n    return output;\n  };\n};\n\nconst mixObject = (origin, target) => {\n  const output = Object.assign(Object.assign({}, origin), target);\n  const blendValue = {};\n\n  for (const key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n\n    return output;\n  };\n};\n\nfunction analyse(value) {\n  const parsed = complex.parse(value);\n  const numValues = parsed.length;\n  let numNumbers = 0;\n  let numRGB = 0;\n  let numHSL = 0;\n\n  for (let i = 0; i < numValues; i++) {\n    if (numNumbers || typeof parsed[i] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i].hue !== undefined) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n\n  return {\n    parsed,\n    numNumbers,\n    numRGB,\n    numHSL\n  };\n}\n\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyse(origin);\n  const targetStats = analyse(target);\n  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return p => `${p > 0 ? target : origin}`;\n  }\n};\n\nexport { mixArray, mixComplex, mixObject };","map":{"version":3,"sources":["C:/Users/jeswa/Documents/online-clipboard/frontend/node_modules/popmotion/dist/es/utils/mix-complex.mjs"],"names":["complex","color","mix","mixColor","isNum","pipe","warning","getMixer","origin","target","v","test","mixComplex","mixArray","from","to","output","numValues","length","blendValue","map","fromThis","i","mixObject","Object","assign","key","undefined","analyse","value","parsed","parse","numNumbers","numRGB","numHSL","hue","template","createTransformer","originStats","targetStats","canInterpolate","p"],"mappings":"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","sourcesContent":["import { complex, color } from 'style-value-types';\r\nimport { mix } from './mix.mjs';\r\nimport { mixColor } from './mix-color.mjs';\r\nimport { isNum } from './inc.mjs';\r\nimport { pipe } from './pipe.mjs';\r\nimport { warning } from 'hey-listen';\r\n\r\nfunction getMixer(origin, target) {\r\n    if (isNum(origin)) {\r\n        return (v) => mix(origin, target, v);\r\n    }\r\n    else if (color.test(origin)) {\r\n        return mixColor(origin, target);\r\n    }\r\n    else {\r\n        return mixComplex(origin, target);\r\n    }\r\n}\r\nconst mixArray = (from, to) => {\r\n    const output = [...from];\r\n    const numValues = output.length;\r\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\r\n    return (v) => {\r\n        for (let i = 0; i < numValues; i++) {\r\n            output[i] = blendValue[i](v);\r\n        }\r\n        return output;\r\n    };\r\n};\r\nconst mixObject = (origin, target) => {\r\n    const output = Object.assign(Object.assign({}, origin), target);\r\n    const blendValue = {};\r\n    for (const key in output) {\r\n        if (origin[key] !== undefined && target[key] !== undefined) {\r\n            blendValue[key] = getMixer(origin[key], target[key]);\r\n        }\r\n    }\r\n    return (v) => {\r\n        for (const key in blendValue) {\r\n            output[key] = blendValue[key](v);\r\n        }\r\n        return output;\r\n    };\r\n};\r\nfunction analyse(value) {\r\n    const parsed = complex.parse(value);\r\n    const numValues = parsed.length;\r\n    let numNumbers = 0;\r\n    let numRGB = 0;\r\n    let numHSL = 0;\r\n    for (let i = 0; i < numValues; i++) {\r\n        if (numNumbers || typeof parsed[i] === \"number\") {\r\n            numNumbers++;\r\n        }\r\n        else {\r\n            if (parsed[i].hue !== undefined) {\r\n                numHSL++;\r\n            }\r\n            else {\r\n                numRGB++;\r\n            }\r\n        }\r\n    }\r\n    return { parsed, numNumbers, numRGB, numHSL };\r\n}\r\nconst mixComplex = (origin, target) => {\r\n    const template = complex.createTransformer(target);\r\n    const originStats = analyse(origin);\r\n    const targetStats = analyse(target);\r\n    const canInterpolate = originStats.numHSL === targetStats.numHSL &&\r\n        originStats.numRGB === targetStats.numRGB &&\r\n        originStats.numNumbers >= targetStats.numNumbers;\r\n    if (canInterpolate) {\r\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\r\n    }\r\n    else {\r\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\r\n        return (p) => `${p > 0 ? target : origin}`;\r\n    }\r\n};\r\n\r\nexport { mixArray, mixComplex, mixObject };\r\n"]},"metadata":{},"sourceType":"module"}